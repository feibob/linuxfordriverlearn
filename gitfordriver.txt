gpio 怎么在代码里面拉高拉低
设备驱动
中断 linux驱动如何实现
android 怎么变成ui显示
sd插入 

目的：看懂驱动，改驱动
i2c：传感器；总线下面的设备驱动，
regulater+arm芯片+外设（供电）

##################
tty是伪字符设备驱动

cmd tty
/dev/pts/0

echo "hello world" > /dev/pts/0 会在tty里面显示



###################
/dev目录，设备所对应的文件
/dev/sd* 块设备所对应的文件；对应磁盘上的分区
磁盘以及磁盘上的每一个分区，都对应一个裸的文件
磁盘mount到文件系统
mount 



###################
总线，设备，驱动关系 （驱动和设备要分离，通过总线）
              设备1||驱动1
              设备2||驱动2
                  总线

每一个驱动在注册（insmod）的时候，他会寻找匹配的设备
总线做的最关键的事情就是match；匹配驱动和设备
plaform总线匹配设备和驱动的名字



###################
驱动与驱动分离



主机驱动与client驱动分离
###################
kobject kernel对象
kobject 可以看作是所有总线，设备，和驱动的抽象基类；一个kobject对应sysfs中的一个目录

内核源代码体现了面向对象的思想



###################
复杂设备驱动

层次化，结构化，上层不依赖与具体硬件，下层与硬件接口


###################
编译进内核，不编译进内核，编译成模块（img里面）


模块可以接受参数

module_param()把一个模块里面的全局变量定义为对模块的输入，你在加载时候所指定的参数，会修改这个参数

###################
模块本身不被编译入内核，控制了内核的大小
模块一旦被加载，与内核中其他部分完全一样
Makefile：一个文本形式的文件，其中包含一些规则告诉make编译哪些文件以及怎样编译这些文件。
Kconfig：一个文本形式的文件，其中主要作用是在内核配置时候，作为配置选项。
.config：文件是在进行内核配置的时候，经过配置后生成的内核编译参考文件。



###################
modinfo xxx.ko
查看模块信息
vermagic 匹配版本


EXPORT_SYMBOL(function)
cat /proc/kallsyms 记录内核里面所有的symbol（上面导出的）


###################
中断上下文；进程上下文
当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称 为该进程的上下文。


上下文context： 上下文简单说来就是一个环境，相对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。
一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。
用户级上下文: 正文、数据、用户堆栈以及共享存储区；
寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；
系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。

最简单的理解：在中断中执行时依赖的环境，就是中断上下文。其他就是进程上下文。

当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文。
当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的上下文，以便在再次执行该进程时，能够必得到切换时的状态执行下去。
在LINUX中，当前进程上下文均保存在进程的任务数据结构中。在发生中断时,内核就在被中断进程的上下文中，在内核态下执行中断服务例程。
但同时会保留所有需要用到的资源，以便中继服务结束时能恢复被中断进程的执行。

http://blog.csdn.net/gangyanliang/article/details/6887128


你的进程的运行的生命周期
并发问题
同步问题
schedule（）用于调度的函数，当我进入这个函数，我睡眠了，当这个函数返回时，我又醒来；并且保存状态
completion 主要作用是用于同步



把进程挂在等待队列上
唤醒等待队列
唤醒进程
######################
等待队列的用法！！！





首先定义等待队列，
添加等待队列
改变进程的状态
调度其他的进程执行
是否被信号唤醒（唤醒则出现错误）
（正常醒来）
将等待队列移除等待队列头
将进程状态改为running
#######################
延时函数

忙等待（cpu空转，消耗cpu）
前提条件：
时间很短，
等的时候不能睡眠，
不然大量消耗cpu资源

睡着延时
#######################
内核定时器
#######################
linux中断底半部机制
Linux中断的顶半部和底半部.：http://blog.csdn.net/zxncvb/article/details/10625181



Linux新内核不支持中断嵌套

优先级
↓中断上下文
↓软中断上下文
↓进程上下文
#######################
DMA:http://baike.baidu.com/link?url=BANdZFBRDkYkJ4cuLqBiPIIWcn1ScPSx3n0meMHGsnaMVBU6DI6hVIixlFr6LdnSpxt8nW9KEzP3868YJa_LTftFu9Fb5GO8jh1IQuXXdEm
控制内存直接和外设进行数据交互（不去先看cache是否命中相应数据）

cache命中问题 cpu读内存，先看cache是否命中，否则读内存





cpu--cache--内存--dma---外设
1：由于dma不读cache ；会导致cache一致性的问题，cache对应的内存被dma改变，而cpu不知道，出错
2：cpu写入数据到cache；而cache在还没有写入内存的时候，dma接受内存相应位置数据到外设，出错

一致性DMA缓冲区 （即关掉这片内存与cache的关联，cpu也只能直接读取这片内存）
总之想办法忽略掉cache，不去使用他就好

#######################
字符设备驱动
lanana (baidu or google)
$ cat /proc/devices 
查看计算机的设备，字符设备，块设备等
内存拷贝
copy_for_muser
copy_to_user

字符设备驱动主体：file_operations


goto语句在linux编程里大量使用（出错处理的时候大量使用）
kernel/Document里面有编写linux代码规范

#########################
系统io分类
http://shensy.iteye.com/blog/1864781
http://blog.csdn.net/sszgg2006/article/details/38664789
阻塞与非阻塞针对的是进程或线程而同步与异步所针对的是功能函数


阻塞io:进程阻塞在io操作上（读写一个文件，读写一个串口，读写单一设备的时候用法哦）
非阻塞io：防止进程阻塞在io操作上（在单一线程里面服务多个io）
io多路复用：允许同时对多个io进行控制
信号驱动io：一种异步通信模型

一个驱动应该同时支持上面四种io方式



#########################
文件描述符：在linux系统中打开文件就会获得文件描述符，它是个很小的正整数。
每个进程在PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针。
 
文件指针：C语言中使用文件指针做为I/O的句柄。
文件指针指向进程用户区中的一个被称为FILE结构的数据结构。
FILE结构包括一个缓冲区和一个文件描述符。
而文件描述符是文件描述符表的一个索引，因此从某种意义上说文件指针就是句柄的句柄（在Windows系统上，文件描述符被称作文件句柄）。

#########################
modprobe 加载模块及其依赖模块